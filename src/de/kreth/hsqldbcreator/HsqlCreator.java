package de.kreth.hsqldbcreator;

import java.io.*;
import java.sql.*;

/**
 * Bietet eine Singleton-Schnittstelle, die eine Connection und Statement 
 * auf eine HSQLDB in jedem beliebigen Projekt bietet. Die Datenbank-Dateien werden im Projektverzeichnis db/ gespeichert.
 * @author markus
 *
 */
public class HsqlCreator implements Statement {

	private static HsqlCreator instance = null;
	private static HsqlCreator testInstance = null;

	private static final String defaultDbFile  = "DatabaseFile";
	protected Connection con;
	protected Statement stm;
	private static String dirName = "db";
	private String fileName;
	protected String location;

	public static HsqlCreator getTestInstance() {
		if(testInstance == null){
			testInstance = new HsqlCreator(defaultDbFile + "Test");
		}
		return testInstance;
	}

	public static HsqlCreator getInstance() {
		if (instance == null)
			instance = new HsqlCreator(defaultDbFile);
		return instance;
	}

	private HsqlCreator(String filename) {
		this.fileName = filename;
		location = dirName + "/" + fileName;
		File verz = new File(dirName);
		if (!verz.exists()) {
			// Unterverzeichnis db anlegen f√ºr die Datenbank-Dateien
			verz.mkdir();
		}
		try {
			// Class.forName("org.hsqldb.jdbcDriver" );

			try {
				con = DriverManager.getConnection("jdbc:hsqldb:file:" + location + ";shutdown=true", "sa", "");

				try {
					stm = con.createStatement();
				}
				catch (SQLException ex) {
					printMsg("ERROR: failed to create Statement from Connection!!!"
								+ ex.getLocalizedMessage());
					// System.err.println("ERROR: failed to create Statement from Connection!!!");
					// System.err.println(ex.getLocalizedMessage());
				}
			}
			catch (SQLException ex) {
				printMsg("ERROR: failed to connect to file " + location
							+ ". Is directory writable?"
							+ ex.getLocalizedMessage());
				// System.err.println("ERROR: failed to connect to file " +
				// location + ". Is directory writable?");
				// System.err.println(ex.getLocalizedMessage());
			}
		}
		catch (Exception e) {
			printMsg("ERROR: failed to load HSQLDB JDBC driver."
						+ e.getLocalizedMessage());
			// System.err.println("ERROR: failed to load HSQLDB JDBC driver.");
			// System.err.println(e.getLocalizedMessage());
		}
	}

	private void printMsg(String msg) {
		System.err.println(msg);
	}

	/**
	 * Exportiert alle (Datenbank-)Dateien des Projekts in das angegebene
	 * Verzeichnis.
	 * 
	 * @param targetDir
	 *            Ziel-Verzeichnis
	 */
	public void exportToDir(File targetDir) {

		File source = new File(dirName);

		if (!targetDir.exists() || !targetDir.isDirectory()) {
			System.err.println("Selected targetDir is not a Directory - Aborting...");
			return;
		}

		File[] sourceFiles = source.listFiles();
		if (sourceFiles != null) {
			for (File file : sourceFiles) {
				if (file.isFile())
					try {
						System.out.println("Copying " + file.getName());
						File target = new File(targetDir.getAbsolutePath()
									+ File.separator + file.getName());

						if (!target.exists())
							target.createNewFile();

						BufferedReader reader = new BufferedReader(
									new FileReader(file));
						BufferedWriter writer = new BufferedWriter(
									new FileWriter(target));
						String line;
						while ((line = reader.readLine()) != null) {
							writer.append(line);
							writer.newLine();
						}
						reader.close();
						writer.flush();
						writer.close();
					}
					catch (FileNotFoundException ex) {
						ex.printStackTrace();
					}
					catch (IOException ex) {
						ex.printStackTrace();
					}
			}
		}

	}

//	public static Connection createConnection() throws SQLException, Exception {
//		HsqlCreator db = new HsqlCreator(defaultDbFile);
//		return db.con;
//	}

	public void commit() throws SQLException {
		con.commit();
	}

	public void rollback(Savepoint arg0) throws SQLException {
		con.rollback(arg0);
	}

	public void setAutoCommit(boolean arg0) throws SQLException {
		con.setAutoCommit(arg0);
	}

	public Savepoint setSavepoint(String arg0) throws SQLException {
		return con.setSavepoint(arg0);
	}

	@Override
   public ResultSet getResultSet() throws SQLException {
		return stm.getResultSet();
	}

	@Override
   public ResultSet executeQuery(String sql) throws SQLException {
		return stm.executeQuery(sql);
	}

	@Override
   public int[] executeBatch() throws SQLException {
		return stm.executeBatch();
	}

	@Override
   public boolean execute(String sql) throws SQLException {
		return stm.execute(sql);
	}

	@Override
   public int executeUpdate(final String sql, final int autoGeneratedKeys)
				throws SQLException {
		return stm.executeUpdate(sql, autoGeneratedKeys);
	}

	@Override
   public int executeUpdate(String sql) throws SQLException {
		return stm.executeUpdate(sql);
	}

	@Override
   public void close() throws SQLException {
		stm.close();
		con.close();
	}

	@Override
	public boolean isWrapperFor(Class<?> arg0) throws SQLException {
		return stm.isWrapperFor(arg0);
	}

	@Override
	public <T> T unwrap(Class<T> arg0) throws SQLException {
		return stm.unwrap(arg0);
	}

	@Override
	public void addBatch(String sql) throws SQLException {
		stm.addBatch(sql);
	}

	@Override
	public void cancel() throws SQLException {
		stm.cancel();
	}

	@Override
	public void clearBatch() throws SQLException {
		stm.clearBatch();
	}

	@Override
	public void clearWarnings() throws SQLException {
		stm.clearWarnings();
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys)
				throws SQLException {
		return stm.execute(sql, autoGeneratedKeys);
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		return stm.execute(sql, columnIndexes);
	}

	@Override
	public boolean execute(String sql, String[] columnNames)
				throws SQLException {
		return stm.execute(sql, columnNames);
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes)
				throws SQLException {
		return stm.executeUpdate(sql, columnIndexes);
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames)
				throws SQLException {
		return stm.executeUpdate(sql, columnNames);
	}

	@Override
	public Connection getConnection() throws SQLException {
		return stm.getConnection();
	}

	@Override
	public int getFetchDirection() throws SQLException {
		return stm.getFetchDirection();
	}

	@Override
	public int getFetchSize() throws SQLException {
		return stm.getFetchSize();
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		return stm.getGeneratedKeys();
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		return stm.getMaxFieldSize();
	}

	@Override
	public int getMaxRows() throws SQLException {
		return stm.getMaxRows();
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		return stm.getMoreResults();
	}

	@Override
	public boolean getMoreResults(int current) throws SQLException {
		return stm.getMoreResults(current);
	}

	@Override
	public int getQueryTimeout() throws SQLException {
		return stm.getQueryTimeout();
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		return stm.getResultSetConcurrency();
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		return stm.getResultSetHoldability();
	}

	@Override
	public int getResultSetType() throws SQLException {
		return stm.getResultSetType();
	}

	@Override
	public int getUpdateCount() throws SQLException {
		return stm.getUpdateCount();
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		return stm.getWarnings();
	}

	@Override
	public boolean isClosed() throws SQLException {
		return stm.isClosed();
	}

	@Override
	public boolean isPoolable() throws SQLException {
		return stm.isPoolable();
	}

	@Override
	public void setCursorName(String name) throws SQLException {
		stm.setCursorName(name);
	}

	@Override
	public void setEscapeProcessing(boolean enable) throws SQLException {
		stm.setEscapeProcessing(enable);
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
		stm.setFetchDirection(direction);
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
		stm.setFetchSize(rows);
	}

	@Override
	public void setMaxFieldSize(int max) throws SQLException {
		stm.setMaxFieldSize(max);
	}

	@Override
	public void setMaxRows(int max) throws SQLException {
		stm.setMaxRows(max);
	}

	@Override
	public void setPoolable(boolean poolable) throws SQLException {
		stm.setPoolable(poolable);
	}

	@Override
	public void setQueryTimeout(int seconds) throws SQLException {
		stm.setQueryTimeout(seconds);
	}

	public static String getDirName() {
		return dirName;
	}

	public static void setTestInstance(HsqlCreator testInstance) {
		HsqlCreator.testInstance = testInstance;
	}

	/**
	 * Noch nicht implementiert.
	 */
	@Override
	public void closeOnCompletion() throws SQLException {	
	   // Nicht implementiert.
	}

	@Override
	public boolean isCloseOnCompletion() throws SQLException {
		return false;
	}

}
